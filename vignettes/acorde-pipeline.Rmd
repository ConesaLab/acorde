---
title: "Step-by-step guide to the acorde pipeline"
author: "Ángeles Arzalluz-Luque"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Step-by-step guide to the acorde pipeline}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


## 1. Introduction

The **acorde** R package contains the necessary functions to reproduce the
pipeline in [this paper](https://www.biorxiv.org/content/10.1101/2021.05.07.441841v1),
a study by *Arzalluz-Luque et al.* in which we analyze networks of isoform co-usage
using single-cell RNA-seq data (scRNA-seq).

The pipeline includes three basic analysis blocks:

1. **Single-cell isoform quantification and filtering**. First, bulk long read data is 
used to generate tissue-specific transcript models. Short-read scRNA-seq data
is then used for isoform quantification, and isoforms are filtered according to
their **Differential Expression** (DE) status across multiple cell types. 

2. **Detection of isoform co-expression**. *acorde* includes the implementation 
of percentile correlations, a novel strategy to obtain noise-robust correlation
estimates from scRNA-Seq data, and a semi-automated clustering approach to detect
modules of co-expressed isoforms acorss cell types.

3. **Differential and co-Differential Isoform Usage analysis**. DIU and co-DIU
analysis are designed to leverage the multiple cell types contained in single-cell
datasets, and enable the detection of genes that show isoform expression 
coordination. To couple these analysis with a biologically interpretable readout,
we incorporate functional annotations onto isoform models, and use 
[tappAS](https://github.com/ConesaLab/tappAS) for functional analysis.

Since both the long read-transcriptome definition procedure and the 
functional analyses in [[1]](#1) are based on external tools, the present R 
package does **not** incorporate neither of these two analysis steps. Instead,
acorde contains the necessary functions and documentation to obtain a set of 
DIU and co-DIU genes using an single-cell, isoform-level expression matrix as 
input.

In addition, we provide all the necessary instructions to reproduce the figures 
and additional analyses included in Arzalluz-Luque et al. [[1]](#1), 
and provide the isoform expression matrix employed during the study as internal 
data in the package.

![Complete acorde pipeline](../images/acorde_pipeline-small.png)

## 2. Installation

Acorde can be installed from GitHub using `devtools`:

```{r, eval = FALSE}
install.packages("devtools")
devtools::install_github("ConesaLab/acorde", build_vignettes = TRUE)

```


## 3. Getting ready

To run the analyses in this vignette, you'll first need to load `acorde`:

```{r setup}
# load acorde
library(acorde)

# load auxiliary packages
suppressPackageStartupMessages({
  library(tibble)
  library(dplyr)
  library(purrr)
  library(furrr)
  library(ggplot2)
})
```

In addition, we'll require some additional packages for data 
handling and formatting. Most of them are signaled as `acorde` dependencies, 
so they will already be installed in your system.

To generate plots, we make use of the `cowplot` R package and the cowplot theme.
After install:

```{r, eval = FALSE}
install.packages("cowplot")
```

you can load and set the theme of your R session as follows:

```{r}
library(cowplot)
theme_set(theme_cowplot())
```



## 4. Input data

The acorde pipeline requires a **single-cell isoform expression** matrix as input.
Single-cell isoform counts should be provided in the form of a `data.frame` or 
`tibble` object including isoforms as rows and cells as columns. Isoform identifiers
can be supplied as `rownames()` or as an additional identifier column, as required
by [tibble](https://tibble.tidyverse.org/articles/tibble.html).

To generate an isoform-level single-cell expression matrix, we first processed long 
read bulk data from ENCODE (provided by Wyman et al. [[2]](#2)) to build a mouse 
neural transcriptome, and then used publicly-available scRNA-seq data by Tasic 
et al. [[3]](#3) to quantify the expression of long read-defined isoforms in mouse 
neural cell types. Details to this process can be found in [our manuscript](https://www.biorxiv.org/content/10.1101/2021.05.07.441841v1) 
(see Supplementary Note and Methods).

If you wish to reproduce the analyses in Arzalluz-Luque et al. [[1]](#1)), you can load the
`tasic_down` object to use our isoform-quantified dataset:

```{r}
# load Tasic dataset
data("tasic_down")

# load Tasic metadata
data("metadata_down")
```

These contain two `tibble` objects. After downsampling and quality control
(see Methods in [[1]](#1)), the `tasic_down` tibble contains expression data 
for **13452 isoforms** and **241 cells** belonging to 7 neural cell types:

```{r, echo = FALSE}
knitr::kable(metadata_down$cell_type %>% table %>% 
               enframe(name = "Cell type", value = "Number of cells"))
```

```{r}
# display format of tasic_down
tasic_down[1:6, 1:8]

# number of cells and isoforms
dim(tasic_down)

```

**Metadata** is contained in the `metadata_down` tibble. This table was generated 
using Tasic et al. supplementary files, which were used to parse cell type labels for 
single-cell IDs (i.e. sequencing run IDs, included in the `run` column), among 
other information:

```{r}
# show information contained in metadata_down
metadata_down %>% colnames

# display cell type labels and abundances
unique(metadata_down$cell_type)
```

See `?tasic_down` and `?metadata_down` for details.

## 5. Isoform Differential Expression across multiple cell types

To select isoforms with robust co-variation across the 7 neural cell types, 
we first applied **multi-group Differential Expression analysis**, which will
detect isoforms that are differentially expressed (DE) in at least one cell type.

To achieve this, we combined the zero-weighting strategy in the [zinbwave](https://bioconductor.org/packages/release/bioc/vignettes/zinbwave/inst/doc/intro.html) 
R package with bulk-designed DE methods [DESeq2](https://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html) 
and [edgeR](https://bioconductor.org/packages/release/bioc/vignettes/edgeR/inst/doc/edgeRUsersGuide.pdf).
Both tools were set to detect DE across multiple groups. The incorporation of 
weights to these analyses and the correct application of both tools to scRNA-seq 
data was done following the 
[Differential Expression section](https://bioconductor.org/packages/release/bioc/vignettes/zinbwave/inst/doc/intro.html#differential-expression) 
in the zinbwave vignette. 

Acorde provides the `cell_type_DE()` function, which constitutes a wrapper to 
these two methodologies. This function takes a `SingleCellExperiment` object
as input, and can run `DESeq2`, `edgeR` or both methods using the `mode` argument.

```{r}
# convert tibble to count matrix
count.matrix <- column_to_rownames(tasic_down, "transcript_id") %>% 
  as.matrix
# round estimated counts from RSEM to generate integer values
count.matrix <- count.matrix %>% round

# create SingleCellExperiment object with Tasic data
library(SingleCellExperiment, quietly = TRUE)

sce <- SingleCellExperiment(assays = list(counts = count.matrix, 
                                          logcounts = log2(count.matrix + 1)),
                            colData = metadata_down)
```

Applying `round()` can generate additional all-zero counts, in spite of the
previous zero count filtering of isoforms. If so, run an additional filtering
step to avoid errors during DE analysis:

```{r}
# filter isoforms with all-zero counts from SCE
sce <- sce[rowSums(counts(sce)) > 0,]
```

By default, `cell_type_DE()` automatically calculates and stores zinbwave weights in the
`weights` slot of the `SingleCellExperiment` object. Alternatively, you may set 
`cell_type_DE(compute_weights = FALSE)` and run `zinbwave()` yourself 
(note that computing weights is a computationally costly step, so we'll use 
the `BiocParallel` R package to parallelize the process):

```{r}
# load biocParallel
library(BiocParallel)

# compute weights
library(zinbwave)

sce <- zinbwave(sce, observationalWeights = TRUE, 
                BPPARAM = MulticoreParam(6))
```

Now we are ready to run isoform-level Differential Expression analysis. We'll
set `cell_type_DE(method = "both")` to be able to compare multi-group DE
results for both edgeR and DESeq2.

```{r}
# run DE analysis using both DESeq2 and edgeR
de_results <- cell_type_DE(sce, AdjPvalue = 0.05, 
                           mode = "both", 
                           compute_weights = FALSE)

# view DE results
de_results
```

To obtain an overview of the number of isoforms that are DE in at least one cell type
reported by each of the methods, we can use the UpSetR package to calculate and
plot the intersection between the results stored in `de_results`:


```{r}
library(UpSetR)

de_isoforms <- list(edgeR = de_results$edgeR %>% select(transcript) %>% unlist,
                    DESeq2 = de_results$DESeq2 %>% select(transcript) %>% unlist)

upset(fromList(de_isoforms), nsets = 6, order.by = "freq", 
      sets.x.label = "DE isoforms \n(AdjP < 0.05)", text.scale = 1.5, 
      set_size.scale_max = 8000)
```

In our study, we preserved an isoform for downstream analysis if it was detected
as significantly DE by *at least one of the methods*, that is, 
we preserved the **union of DE results**. In addition, isoforms were removed if
they belonged to genes with a single DE isoform since, in practice, no 
differential splicing can occur for single-isoform genes (or for genes for which
only one isoform presents expression variation across cell types). Isoform - gene
correspondence is provided by acorde in the `gene_tr_ID` data object.

```{r}
# keep the union of edgeR and DESeq2 DE isoforms
tasic_de <- tasic_down %>% 
  filter(transcript_id %in% de_results$edgeR$transcript |
         transcript_id %in% de_results$DESeq2$transcript)

# load and display gene-isoform table
data("gene_tr_ID")
head(gene_tr_ID)

# remove transcripts from single-isoform genes
multi_iso <- split(tasic_de$transcript_id,
                  gene_tr_ID[match(tasic_de$transcript_id, gene_tr_ID$transcript_id),]$gene_id)
multi_iso <- multi_iso[map_int(multi_iso, length) > 1] %>% unlist

tasic_sp <- tasic_de %>%
  filter(transcript_id %in% multi_iso)
```

As a summary, here's a comparison of the number of isoforms remaining in our 
expression matrix after performing these filtering steps:

```{r, echo = FALSE}
knitr::kable(tibble(Object = c("tasic_down", "tasic_de", "tasic_sp"), 
                    Content = c("All isoforms", "DE isoforms", 
                            "DE isoforms from multi-isoform genes"),
                    Isoform_no = c(nrow(tasic_down), nrow(tasic_de),
                                  nrow(tasic_sp))))
```




### References

If you use *acorde* in your research, please cite:

- <a id="1">[1]</a>
Angeles Arzalluz-Luque, Pedro Salguero, Sonia Tarazona, Ana Conesa:
*Acorde*: unraveling functionally-interpretable networks of isoform co-usage 
from single cell data. *bioRxiv* 2021.05.07.441841 (2021); 
doi: https://doi.org/10.1101/2021.05.07.441841


Long-read data was obtained from the [ENCODE consortium](http://encodeproject.org/),
and made publicly available by Wyman et al. in their bioRxiv preprint:

- <a id="2">[2]</a>
Dana Wyman, Gabriela Balderrama-Gutierrez, Fairlie Reese, 
Shan Jiang, Sorena Rahmanian, Weihua Zeng, Brian Williams, Diane Trout, Whitney 
England, Sophie Chu, Robert C. Spitale, Andrea Tenner, Barbara Wold, Ali Mortazavi:
A technology-agnostic long-read analysis pipeline for transcriptome discovery 
and quantification. *bioRxiv* 672931 (2020); doi: https://doi.org/10.1101/672931 

Short-read scRNA-seq data was obtained from Tasic et al. (2016): 

- <a id="3">[3]</a>
Tasic, B. et al. Adult mouse cortical cell taxonomy revealed by single cell 
transcriptomics. *Nature Neuroscience*. 19, 335–346 (2016).
